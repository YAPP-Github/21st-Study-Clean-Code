# 7장 : 오류 처리

## 서론

<aside>
💡 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다

</aside>

여기 저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 불가능하다

오류 처리 코드로 인해 프로그램 논리를 이해하기 어렵다면 깨끗한 코드가 아니다!

> 우아하고 고상하게 오류를 처리하는 기법과 고려 사항 몇 가지를 알아보자
> 

## 오류 코드보다 예외를 사용하라

### 예외를 지원하지 않는 언어

```tsx
void sendShutDown(){
   const handle = getHandle(DEV1);

   if(handle != DeviceHandle.INVALID) { 
      ...
      if(record.getStatus() != DEVICE_SUSPENDED) {...}
   }
}
```

1. 오류 플래그 설정
2. 호출자에게 오류 코드 반환

그러나 이렇게 하면 호출자 코드가 복잡해진다

- 논리가 오류 처리 코드와 뒤섞여 버린다

함수를 호출한 즉시 오류를 확인해야 하기 때문이다 (그리고 이 단계는 잊어버리기 쉽다)

## 오류가 발생하면 예외를 던지자

```tsx
void sendShutDown(){
   try {
      tryToShutDown();
   } catch(e){
      logger.log(e)
   }
}

void tryToShutDown () {
    const handle = getHandle(DEV1);
    const record = retrieveDeviceRecord(handle)
    ...
}
```

디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리했다

각 개념을 독립적으로 살펴보고 이해할 수 있다

### Try Catch Finally 문부터 작성하라

```tsx
function retrieveSection(name: string){
   try{
      FileInputStream stream = new FileInputStream(name)

      /* 예외가 발생하지 않는다고 가정하고 로직 실행.. */
      stream.close()

   } catch(e){
      throw new StorageException(e)
   }
}
```

**try 블록은 트랜잭션과 비슷하다**

- try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다
- try 블록 안에서는 오류나 예외가 전혀 발생하지 않는다고 가정하고 나머지 논리를 실행한다

TDD에 적용한다면?

1. 강제로 예외를 일으키는 테스트 케이스를 작성하고
2. 테스트를 통과하게 코드를 작성한다

→ 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 된다

### 미확인 예외를 사용하라

**확인된 예외는 OCP(개방 폐쇠 원칙)을 위반한다**

throw 경로에 위치하는 모든 함수가 하위 함수에서 던지는 예외를 알아야 함으로 **캡슐화도 깨진다**

- 하위 단계에서 코드를 변경하면 상위 단계의 함수 코드를 전부 고쳐야 한다!
- ex) 하위 함수에서 확인된 예외를 던졌는데, catch 블록이 세 단계 위에 있는 상황

### 예외에 의미를 제공하라

<aside>
💡 예외를 던질 때는 전후 상황을 충분히 덧붙인다
   ex) 실패한 연산 이름, 실패 유형

</aside>

### 호출자를 고려해 예외 클래스를 정의하라

오류를 분류하는 방법

1. 오류가 발생한 위치 (컴포넌트 등)
2. 오류의 유형 (네트워크, 디바이스, 프로그래밍 오류 등)

**그러나 오류를 잡아내는 방법도 중요하다**

외부 API를 사용할 때는 상위 클래스로 감싸서 여러 오류 유형을 1개의 유형 하나로 변환하자

- 외부 API와 프로그램 사이에서 의존성이 크게 줄어든다
- 감싸기 클래스에서 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉽다
- 외부 API 인터페이스에 의존하지 않고, 우리 만의 방식으로 편리하게 바꿀 수 있다

### 정상 흐름을 정의하라

```tsx
try {
   MealExpense expense = expenseReportDAO.getMeals(employee.getID())
   m_total += expenses.getTotal()
} catch(MealExpenseNotFound e){
   m_totla += expenses.getTotal()
}
```

때때로 예외를 던져 프로그램을 중단하는 방식이 정합하지 않은 때도 있다

- 예외가 논리를 따라가기 어렵게 만든다

**특수 상황을 처리할 필요가 없다면 더 좋지 않을까?**

- ExpenseReportDAO를 고쳐 청구한 식비가 없다면 
일일 기본 식비를 반환하는 MealExpense 객체를 반환한다
    
    

**이를 특수 사례 패턴이라 부른다**

- 클래스/객체를 조작해 특수 사례를 처리하는 방식이다
- (클래스/객체가 예외 상황을 캡슐화 해서 처리하므로)클라이언트 코드가 예외 상황을 처리할 필요가 없어진다

### null을 반환하지 마라

한 줄 건너 하나씩 Null을 확인하는 코드로 가득한 어플리케이션..

- 일거리를 많이 만든다
- 호출자에게 문제를 떠넘긴다
- 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠진다

대신에 예외를 던지거나 특수 사례 객체를 반환한다

### null을 전달하지 마라

그러나 대다수 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다..

- 예외 던지기 : 상위 단계에서 예외를 처리 해야 함
- assert : 문서화는 잘 되지만 여전히 실행 오류가 발생할 수 있음
