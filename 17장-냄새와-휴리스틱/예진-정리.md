# 17장 냄새와 휴리스틱

- '휴리스틱'이란, '발견법' 이라고도 불리며 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법이다. 'Find out', 'Discover'이라는 의미를 가지며 어떠한 문제를 해결할 수 있는 방법이 올바른 것인지 수학적으로 증명되지 않았다면 휴리스틱 한 것이고, 그렇지 않다면 휴리스틱 하지 않은 것이다.
- 컴퓨터 공학에서 휴리스틱 : 컴퓨터 공학에서 발견법은 해결법이 정확히 해결되는가에 대한 문제를 배제하고, 경험과 직관을 통해, 일반적으로 좋은 해결법이나, 보다 간단한 해결법을 찾고자 하는 방법이다. 예를 들어 상업적인 컴퓨터 바이러스 검색 엔진들은 발견법으로 특정 속성또는 특징을 찾아 바이러스를 찾아낸다. 그러나 잠재적으로 정확도가 떨어질 수 있다.

# 공통

## G2 : 당연한 동작을 구현하지 않는다

- 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다. 당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다. 저자를 신뢰하지 못하므로 코드를 일일이 살펴야 한다.

## G3 : 경계를 올바로 처리하지 않는다

- 코드는 올바로 동작해야 한다. 너무나도 당연한 말이다. 그런데 우리는 올바른 동작이 아주 복잡하다는 사실을 자주 간과한다.
- 모든 경계 조건, 모든 구석지 ㄴ곳, 모든 가벽, 모든 예외는 우아하고 직관적인 알고리즘을좌초시킬 암초다. 스스로의 직관에 의존하지 마라. 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.

## G4 : 안전 절차 무시

- 컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질지 모르지만 자칫하면 끝없는 디버깅에 시달린다. 실패하는 테스트 케이스를 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.

## G5 : 중복

- 이 책에 나오는 가장 중요한 규칙 중 하나이므로 심각하게 숙고하기 바란다.
- 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라. 이렇듯 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다. 다른 프로그래머들이 그만큼 어휘를 사용하기 쉬워진다. 추상화 수준을 높였으므로 구현이 빨라지고 오류가 적어진다.
- 가장 뻔한 유형은 똑같은 코드가 여러 차례 나오는 중복이다. 프로그래머가 미친듯이 마우스로 긁어다 여기저기로 복사한 듯이 보이는 코드다. 이런 중복은 간단한 함수로 교체한다.

## G6 : 추상화 수준이 올바르지 못하다

- 추상화로 개념을 분리할 때는 철저해야 한다. 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.

## G7 : 기초 클래스가 파생 클래스에 의존한다

- 기초 클래스와 파생 클래스로 나누는 가장 흔한 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서다. 그러므로 기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다는 말이다. 일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다.

## G8 : 과도한 정보

- 잘 정의된 모듈은 인터페이스가 아주 작으면서도 많은 동작이 가능하다. 부실하게 정의된 모듈은 인터페이스가 구질구질하며, 간단한 동작 하나에도 온갖 인터페이스가 필요하다. 인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라. 정보를 제한해 결합도를 낮춰라.

## G9 : 죽은 코드

- 죽은 코드란 실행되지 않는 코드를 가리킨다. 불가능한 조건을 확인하는 if 문과 throw 문이 없는 try 문에서 catch 블록이 좋은 예다.
- 죽은 코드를 발견하면 올바른 행동을 취하기 바란다. 적절한 장례식을 치뤄주라. 시스템에서 제거하라.

## G10 : 수직 분리

- 변수와 함수는 사용되는 위치에 가깝게 정의한다. 지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치해야 한다. 비공개 함수는 처음으로 호출한 직후에 정의한다.

## G11 : 일관성 부족

- 표기법은 신중하게 선택하며, 일단 선택한 표기법은 신중하게 따른다. 한 메서드를 processVerificationRequest라 명명했다면 다른 메서드도 (processDeletionRequest처럼) 유사한 이름을 사용한다.
- 착실하게 적용한다면 이처럼 간단한 일관성만으로도 코드를 읽고 수정하기가 대단히 쉬워진다.

## G12 : 잡동사니

- 비어 있는 개본 생성자가 왜 필요한가? 아무도 사용하지 않는 함수, 정보를 제공하지 못하는 주석이 좋은 예다. 모두가, 코드만 복잡하게 만들 뿐이므로 제거해야 마땅하다.

## G13 : 인위적 결함

- 서로 무관한 개념을 인위적으로 결합하지 않는다. 함수, 상수, 변수를 선언할 때는 시간을 들여 올바른 위치를 고민한다. 그저 당장 편한 곳에 선언하고 내버려두면 안 된다.

## G14 : 기능 욕심

- 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안 된다.

## G16 : 모호한 의도

- 코드를 짤 때는 의도를 최대한 분명히 밝힌다. 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법 등은 모두 저자의 의도를 흐린다.

## G17 : 잘못 지운 책임

- 코드는 독자가 자연스럽게 기대할 위치에 배치한다.

## G18 : 부적절한 static 함수

- 일반적으로 static 함수보다 인스턴스 함수가 더 좋다. 조금이라도 의심스럽다면 인스턴스 함수로 정의한다. 반드시 static 함수로 정의해야하겠다면 재정의할 가능성은 없는지 꼼꼼히 따져본다.

## G20 : 이름과 기능이 일치하는 함수

- 이름만으로 분명하지 않기에 구현을 살피거나 문서를 뒤적여야 한다면 더 좋은 이름으로 바꾸거나 아니면 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

## G23 : If/Else 혹은 Switch/Case 문보다 다형성을 사용하라.

- 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 switch 문을 대신한다.

## G24 : 표준 표기법을 따르라

- 팀은 업계 표준에 기반한 구현 표준을 따랴아 한다.

## G25: 매직 숫자는 명명된 상수로 교체하라.

- 일반적으로 코드에서 숫자를 사용하지 말라는 규칙이다. 숫자는 명명된 상수 뒤로 숨기라는 의미다.
- 예를 들어 86, 400이라는 숫자는 SECONDS_PER_DAY라는 상수 뒤로 숨긴다.

## G28 : 조건을 캡슐화하라

- 부울 논리는 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.

```java
// GOOD
if(shouldBeDeleted(timer))
  // ...

// BAD
if(timer.hasExpired() && !timer.isRecurrent())
  // ...
```

## G29 : 부정 조건은 피하라

- 부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하면 긍정 조건으로 표현한다.

```java
// GOOD
if(buffer.shouldCompact())
  // ...

// BAD
if(!buffer.shouldNotCompact())
  // ...
```

# 이름

## N1 : 서술적인 이름을 사용하라

- 이름은 성급하게 정하지 않는다. 서술적인 이름을 신중하게 고른다. 소프트웨어가 진화하면 의미도 변하므로 선택한 이름이 적합한지 자주 되돌아본다.

## N2 : 적절한 추상화 수준에서 이름을 선택하라

- 구현을 드러내는 이름은 피하라. 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라.

## N3 : 가능하다면 표준 명명법을 사용하라

- 코드는 이 언어에 속하는 용어를 열심히 써야 한다. 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.

## N4 : 명확한 이름

- 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다. 예를 들어 함수가 수행하는 기능에 따라, 'doRename'이라는 이름보다 'renamePageAndOptionallyAllReferences' 라는 이름이 훨씬 좋을 수도 있다.

## N5 : 긴 범위(scope)는 긴 이름을 사용하라

- 이름 길이는 범위 길이에 비례해야 한다. 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 하지만 범위가 길어지면 긴 이름을 사용한다.

```java
private void rollMany(int n, int pins){
  for(int i=0; i<n ; i++)
    g.roll(pins);
}
```

- 위와 같이 범위가 5줄 안팎이라면 i나 j와 같은 변수 이름도 괜찮다. 오히려 변수 i를 rollCount라고 썼다면 헷갈릴 터이다.
- 반면 이름이 짧은 변수나 함수는 범위가 길어지면 의미를 잃는다. 그러므로 이름 범위가 길수록 이름을 정확하고 길게 짓는다.

## N6 : 인코딩을 피하라

- 이름에 유형 정보나 범위 정보를 넣어서는 안 된다. 오늘날 개발 환경에서는 이름 앞에 `m_`이나 `f`와 같은 접두어가 불필요하다. 프로젝트 이름이나 하위 시스템 이름에 (시각적 이미지 시스템이라는 뜻으로) `vis_`와 같은 접두어도 불필요하다.
- 중복된 정보는 독자만 혼란하게 만든다. 오늘날 환경은 이름을 조작하지 않고도 모든 정보를 제공하므로, 헝가리안 표기법의 오염에서 이름을 보호하라.

# 테스트

## T1 : 불충분한 테스트

- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다. 테스트 케이스가 확인하지 않은 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.

## T2 : 커버리즈 도구를 사용하라!

- 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다. 커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스 등을 찾기 쉬워진다.

## T3 : 사소한 테스트를 건너뛰지 마라

- 사소한 테스트는 짜기 쉽다. 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다.

## T5 : 경계 조건을 테스트하라

- 경계 조건은 각별히 신경 써서 테스트한다. 알고리즘의 중앙 조건은 올바로 짜놓고 경계 조건에서 실수하는 경우가 흔하다.

## T6 : 버그 주변은 철저히 테스트하라

- 버그는 서로 모이는 경향이 있다. 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.

## T7 : 실패 패턴을 살펴라

- 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다. 합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.

## T8 : 테스트 커버리지 패턴을 살펴라

- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.

## T9 : 테스트는 빨라야 한다.

- 느린 테스트 케이스는 실행하지 않게 된다.
